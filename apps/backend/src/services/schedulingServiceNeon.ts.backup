/**
 * Scheduling Service (Neon PostgreSQL)
 * Handles availability management, session booking, and appointment tracking
 */

import { query } from '../config/neon.js';
import { logger } from '../utils/logger.js';
import { v4 as uuidv4 } from 'uuid';

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

export interface AvailabilitySlot {
  id: string;
  consultant_id: string;
  day_of_week?: number;
  date_specific?: string;
  start_time: string;
  end_time: string;
  duration_minutes: number;
  max_concurrent_bookings: number;
  timezone: string;
  is_recurring: boolean;
  recurring_until?: string;
  created_at: Date;
  updated_at: Date;
}

export interface SessionBooking {
  id: string;
  bilan_id: string;
  beneficiary_id: string;
  consultant_id: string;
  scheduled_date: string;
  scheduled_start_time: string;
  scheduled_end_time: string;
  duration_minutes: number;
  timezone: string;
  status: string;
  session_type: string;
  meeting_format: string;
  meeting_location?: string;
  meeting_link?: string;
  beneficiary_notes?: string;
  consultant_notes?: string;
  preparation_materials?: string;
  availability_slot_id?: string;
  confirmed_at?: Date;
  completed_at?: Date;
  cancelled_at?: Date;
  cancellation_reason?: string;
  attended?: boolean;
  beneficiary_rating?: number;
  beneficiary_feedback?: string;
  created_at: Date;
  updated_at: Date;
}

export interface ConsultantAnalytics {
  consultant_id: string;
  total_sessions: number;
  completed_sessions: number;
  cancelled_sessions: number;
  average_rating?: number;
  total_hours: number;
  updated_at: Date;
}

// ============================================================================
// SCHEDULING SERVICE CLASS
// ============================================================================

class SchedulingServiceNeon {
  /**
   * Create availability slot for consultant
   */
  async createAvailabilitySlot(
    consultantId: string,
    data: {
      day_of_week?: number;
      date_specific?: string;
      start_time: string;
      end_time: string;
      duration_minutes?: number;
      max_concurrent_bookings?: number;
      timezone?: string;
      is_recurring?: boolean;
      recurring_until?: string;
    }
  ): Promise<AvailabilitySlot> {
    // Validate time range
    if (data.start_time >= data.end_time) {
      throw new Error('Start time must be before end time');
    }

    const slotId = uuidv4();

    const result = await query<AvailabilitySlot>(
      null,
      `INSERT INTO availability_slots (
        id, consultant_id, day_of_week, date_specific, start_time, end_time,
        duration_minutes, max_concurrent_bookings, timezone, is_recurring, recurring_until,
        created_at, updated_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, NOW(), NOW())
      RETURNING *`,
      [
        slotId,
        consultantId,
        data.day_of_week || null,
        data.date_specific || null,
        data.start_time,
        data.end_time,
        data.duration_minutes || 120,
        data.max_concurrent_bookings || 1,
        data.timezone || 'UTC',
        data.is_recurring || false,
        data.recurring_until || null
      ]
    );

    logger.info(`Availability slot created: ${slotId}`, { consultantId });
    return result[0];
  }

  /**
   * Get available slots for consultant
   */
  async getAvailableSlotsForConsultant(
    consultantId: string,
    filters?: {
      dayOfWeek?: number;
      dateFrom?: string;
      dateTo?: string;
    }
  ): Promise<AvailabilitySlot[]> {
    let whereClause = 'WHERE consultant_id = $1';
    const params: any[] = [consultantId];
    let paramIndex = 2;

    if (filters?.dayOfWeek !== undefined) {
      whereClause += ` AND day_of_week = $${paramIndex}`;
      params.push(filters.dayOfWeek);
      paramIndex++;
    }

    if (filters?.dateFrom) {
      whereClause += ` AND (date_specific IS NULL OR date_specific >= $${paramIndex})`;
      params.push(filters.dateFrom);
      paramIndex++;
    }

    if (filters?.dateTo) {
      whereClause += ` AND (date_specific IS NULL OR date_specific <= $${paramIndex})`;
      params.push(filters.dateTo);
      paramIndex++;
    }

    const result = await query<AvailabilitySlot>(
      null,
      `SELECT * FROM availability_slots ${whereClause} ORDER BY start_time`,
      params
    );

    return result;
  }

  /**
   * Update availability slot
   */
  async updateAvailabilitySlot(
    slotId: string,
    consultantId: string,
    updates: Partial<AvailabilitySlot>
  ): Promise<AvailabilitySlot> {
    const fields: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    Object.entries(updates).forEach(([key, value]) => {
      if (value !== undefined && key !== 'id' && key !== 'created_at' && key !== 'consultant_id') {
        fields.push(`${key} = $${paramIndex}`);
        values.push(value);
        paramIndex++;
      }
    });

    if (fields.length === 0) {
      throw new Error('No fields to update');
    }

    fields.push(`updated_at = NOW()`);
    values.push(slotId, consultantId);

    const result = await query<AvailabilitySlot>(
      null,
      `UPDATE availability_slots 
       SET ${fields.join(', ')} 
       WHERE id = $${paramIndex} AND consultant_id = $${paramIndex + 1}
       RETURNING *`,
      values
    );

    if (result.length === 0) {
      throw new Error('Availability slot not found or unauthorized');
    }

    logger.info(`Availability slot updated: ${slotId}`);
    return result[0];
  }

  /**
   * Delete availability slot
   */
  async deleteAvailabilitySlot(slotId: string, consultantId: string): Promise<void> {
    const result = await query(
      null,
      `DELETE FROM availability_slots WHERE id = $1 AND consultant_id = $2`,
      [slotId, consultantId]
    );

    logger.info(`Availability slot deleted: ${slotId}`);
  }

  /**
   * Check for booking conflicts
   */
  async checkBookingConflicts(
    consultantId: string,
    scheduledDate: string,
    startTime: string,
    endTime: string,
    excludeBookingId?: string
  ): Promise<boolean> {
    let whereClause = `WHERE consultant_id = $1 
                       AND scheduled_date = $2 
                       AND status NOT IN ('CANCELLED', 'COMPLETED')`;
    const params: any[] = [consultantId, scheduledDate];
    let paramIndex = 3;

    if (excludeBookingId) {
      whereClause += ` AND id != $${paramIndex}`;
      params.push(excludeBookingId);
      paramIndex++;
    }

    const bookings = await query<SessionBooking>(
      null,
      `SELECT * FROM session_bookings ${whereClause}`,
      params
    );

    // Check time overlap
    for (const booking of bookings) {
      const bookingStart = booking.scheduled_start_time;
      const bookingEnd = booking.scheduled_end_time;

      if (startTime < bookingEnd && endTime > bookingStart) {
        return true; // Conflict found
      }
    }

    return false; // No conflict
  }

  /**
   * Validate bilan for booking
   */
  async validateBilanForBooking(bilanId: string): Promise<{
    valid: boolean;
    message?: string;
  }> {
    const result = await query<any>(
      null,
      `SELECT id, status FROM bilans WHERE id = $1`,
      [bilanId]
    );

    if (result.length === 0) {
      return { valid: false, message: 'Bilan not found' };
    }

    const bilan = result[0];

    if (bilan.status === 'ARCHIVED' || bilan.status === 'COMPLETED') {
      return { valid: false, message: `Cannot book sessions for ${bilan.status.toLowerCase()} bilan` };
    }

    return { valid: true };
  }

  /**
   * Create session booking
   */
  async createSessionBooking(data: {
    bilan_id: string;
    beneficiary_id: string;
    consultant_id: string;
    scheduled_date: string;
    scheduled_start_time: string;
    scheduled_end_time: string;
    duration_minutes?: number;
    timezone?: string;
    session_type?: string;
    meeting_format?: string;
    meeting_location?: string;
    meeting_link?: string;
    beneficiary_notes?: string;
    preparation_materials?: string;
    availability_slot_id?: string;
  }): Promise<SessionBooking> {
    // Validate bilan
    const bilanValidation = await this.validateBilanForBooking(data.bilan_id);
    if (!bilanValidation.valid) {
      throw new Error(bilanValidation.message);
    }

    // Check for conflicts
    const hasConflict = await this.checkBookingConflicts(
      data.consultant_id,
      data.scheduled_date,
      data.scheduled_start_time,
      data.scheduled_end_time
    );

    if (hasConflict) {
      throw new Error('Time slot conflicts with existing booking');
    }

    const bookingId = uuidv4();

    const result = await query<SessionBooking>(
      null,
      `INSERT INTO session_bookings (
        id, bilan_id, beneficiary_id, consultant_id, scheduled_date,
        scheduled_start_time, scheduled_end_time, duration_minutes, timezone,
        status, session_type, meeting_format, meeting_location, meeting_link,
        beneficiary_notes, preparation_materials, availability_slot_id,
        created_at, updated_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, NOW(), NOW())
      RETURNING *`,
      [
        bookingId,
        data.bilan_id,
        data.beneficiary_id,
        data.consultant_id,
        data.scheduled_date,
        data.scheduled_start_time,
        data.scheduled_end_time,
        data.duration_minutes || 120,
        data.timezone || 'UTC',
        'SCHEDULED',
        data.session_type || 'FOLLOW_UP',
        data.meeting_format || 'VIDEO',
        data.meeting_location || null,
        data.meeting_link || null,
        data.beneficiary_notes || null,
        data.preparation_materials || null,
        data.availability_slot_id || null
      ]
    );

    logger.info(`Session booking created: ${bookingId}`, { bilanId: data.bilan_id });
    return result[0];
  }

  // Continued in Part 2...

  /**
   * Confirm booking (consultant action)
   */
  async confirmBooking(bookingId: string, consultantId: string, notes?: string): Promise<SessionBooking> {
    // Verify booking exists and belongs to consultant
    const existing = await query<SessionBooking>(
      null,
      `SELECT * FROM session_bookings WHERE id = $1 AND consultant_id = $2`,
      [bookingId, consultantId]
    );

    if (existing.length === 0) {
      throw new Error('Booking not found or unauthorized');
    }

    if (existing[0].status !== 'SCHEDULED') {
      throw new Error(`Cannot confirm booking with status: ${existing[0].status}`);
    }

    const result = await query<SessionBooking>(
      null,
      `UPDATE session_bookings 
       SET status = 'CONFIRMED', 
           consultant_notes = $1,
           confirmed_at = NOW(),
           updated_at = NOW()
       WHERE id = $2
       RETURNING *`,
      [notes || null, bookingId]
    );

    logger.info(`Booking confirmed: ${bookingId}`);
    return result[0];
  }

  /**
   * Get beneficiary bookings
   */
  async getBeneficiaryBookings(
    beneficiaryId: string,
    filters?: {
      status?: string;
      dateFrom?: string;
      dateTo?: string;
    },
    page?: number,
    limit?: number
  ): Promise<{ bookings: SessionBooking[]; total: number }> {
    let whereClause = 'WHERE beneficiary_id = $1';
    const params: any[] = [beneficiaryId];
    let paramIndex = 2;

    if (filters?.status) {
      whereClause += ` AND status = $${paramIndex}`;
      params.push(filters.status);
      paramIndex++;
    }

    if (filters?.dateFrom) {
      whereClause += ` AND scheduled_date >= $${paramIndex}`;
      params.push(filters.dateFrom);
      paramIndex++;
    }

    if (filters?.dateTo) {
      whereClause += ` AND scheduled_date <= $${paramIndex}`;
      params.push(filters.dateTo);
      paramIndex++;
    }

    // Get total count
    const countResult = await query<{ count: number }>(
      null,
      `SELECT COUNT(*)::int as count FROM session_bookings ${whereClause}`,
      params
    );

    const total = countResult[0]?.count || 0;

    // Get bookings with pagination
    let query_text = `SELECT * FROM session_bookings ${whereClause} ORDER BY scheduled_date DESC, scheduled_start_time DESC`;

    if (page && limit) {
      const offset = (page - 1) * limit;
      query_text += ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
      params.push(limit, offset);
    }

    const bookings = await query<SessionBooking>(null, query_text, params);

    return { bookings, total };
  }

  /**
   * Get consultant bookings
   */
  async getConsultantBookings(
    consultantId: string,
    filters?: {
      status?: string;
      dateFrom?: string;
      dateTo?: string;
    },
    page?: number,
    limit?: number
  ): Promise<{ bookings: SessionBooking[]; total: number }> {
    let whereClause = 'WHERE consultant_id = $1';
    const params: any[] = [consultantId];
    let paramIndex = 2;

    if (filters?.status) {
      whereClause += ` AND status = $${paramIndex}`;
      params.push(filters.status);
      paramIndex++;
    }

    if (filters?.dateFrom) {
      whereClause += ` AND scheduled_date >= $${paramIndex}`;
      params.push(filters.dateFrom);
      paramIndex++;
    }

    if (filters?.dateTo) {
      whereClause += ` AND scheduled_date <= $${paramIndex}`;
      params.push(filters.dateTo);
      paramIndex++;
    }

    // Get total count
    const countResult = await query<{ count: number }>(
      null,
      `SELECT COUNT(*)::int as count FROM session_bookings ${whereClause}`,
      params
    );

    const total = countResult[0]?.count || 0;

    // Get bookings with pagination
    let query_text = `SELECT * FROM session_bookings ${whereClause} ORDER BY scheduled_date DESC, scheduled_start_time DESC`;

    if (page && limit) {
      const offset = (page - 1) * limit;
      query_text += ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
      params.push(limit, offset);
    }

    const bookings = await query<SessionBooking>(null, query_text, params);

    return { bookings, total };
  }

  /**
   * Complete session
   */
  async completeSession(
    bookingId: string,
    data: {
      attended: boolean;
      beneficiary_rating?: number;
      beneficiary_feedback?: string;
    }
  ): Promise<SessionBooking> {
    const result = await query<SessionBooking>(
      null,
      `UPDATE session_bookings 
       SET status = 'COMPLETED',
           attended = $1,
           beneficiary_rating = $2,
           beneficiary_feedback = $3,
           completed_at = NOW(),
           updated_at = NOW()
       WHERE id = $4
       RETURNING *`,
      [data.attended, data.beneficiary_rating || null, data.beneficiary_feedback || null, bookingId]
    );

    if (result.length === 0) {
      throw new Error('Booking not found');
    }

    // Update analytics if attended
    if (data.attended) {
      await this.updateSessionAnalytics(result[0].consultant_id);
    }

    logger.info(`Session completed: ${bookingId}`, { attended: data.attended });
    return result[0];
  }

  /**
   * Cancel booking
   */
  async cancelBooking(bookingId: string, cancellationReason: string): Promise<SessionBooking> {
    const result = await query<SessionBooking>(
      null,
      `UPDATE session_bookings 
       SET status = 'CANCELLED',
           cancellation_reason = $1,
           cancelled_at = NOW(),
           updated_at = NOW()
       WHERE id = $2
       RETURNING *`,
      [cancellationReason, bookingId]
    );

    if (result.length === 0) {
      throw new Error('Booking not found');
    }

    logger.info(`Booking cancelled: ${bookingId}`);
    return result[0];
  }

  /**
   * Update session analytics for consultant
   */
  private async updateSessionAnalytics(consultantId: string): Promise<void> {
    // Get all bookings for consultant
    const bookings = await query<SessionBooking>(
      null,
      `SELECT * FROM session_bookings WHERE consultant_id = $1`,
      [consultantId]
    );

    const totalSessions = bookings.length;
    const completedSessions = bookings.filter(b => b.status === 'COMPLETED').length;
    const cancelledSessions = bookings.filter(b => b.status === 'CANCELLED').length;

    const ratingsArray = bookings
      .filter(b => b.beneficiary_rating !== null && b.beneficiary_rating !== undefined)
      .map(b => b.beneficiary_rating!);

    const averageRating = ratingsArray.length > 0
      ? ratingsArray.reduce((sum, r) => sum + r, 0) / ratingsArray.length
      : null;

    const totalHours = bookings
      .filter(b => b.status === 'COMPLETED')
      .reduce((sum, b) => sum + (b.duration_minutes / 60), 0);

    // Check if analytics exist
    const existing = await query<ConsultantAnalytics>(
      null,
      `SELECT * FROM consultant_analytics WHERE consultant_id = $1`,
      [consultantId]
    );

    if (existing.length > 0) {
      // Update existing
      await query(
        null,
        `UPDATE consultant_analytics 
         SET total_sessions = $1,
             completed_sessions = $2,
             cancelled_sessions = $3,
             average_rating = $4,
             total_hours = $5,
             updated_at = NOW()
         WHERE consultant_id = $6`,
        [totalSessions, completedSessions, cancelledSessions, averageRating, totalHours, consultantId]
      );
    } else {
      // Insert new
      await query(
        null,
        `INSERT INTO consultant_analytics (
          consultant_id, total_sessions, completed_sessions, cancelled_sessions,
          average_rating, total_hours, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, NOW())`,
        [consultantId, totalSessions, completedSessions, cancelledSessions, averageRating, totalHours]
      );
    }

    logger.info(`Analytics updated for consultant: ${consultantId}`);
  }

  /**
   * Get consultant analytics
   */
  async getConsultantAnalytics(
    consultantId: string,
    dateRange?: {
      dateFrom?: string;
      dateTo?: string;
    }
  ): Promise<ConsultantAnalytics> {
    let whereClause = 'WHERE consultant_id = $1';
    const params: any[] = [consultantId];
    let paramIndex = 2;

    if (dateRange?.dateFrom) {
      whereClause += ` AND scheduled_date >= $${paramIndex}`;
      params.push(dateRange.dateFrom);
      paramIndex++;
    }

    if (dateRange?.dateTo) {
      whereClause += ` AND scheduled_date <= $${paramIndex}`;
      params.push(dateRange.dateTo);
      paramIndex++;
    }

    // Get analytics from database
    const result = await query<ConsultantAnalytics>(
      null,
      `SELECT * FROM consultant_analytics WHERE consultant_id = $1`,
      [consultantId]
    );

    if (result.length > 0) {
      return result[0];
    }

    // If no analytics exist, create default
    return {
      consultant_id: consultantId,
      total_sessions: 0,
      completed_sessions: 0,
      cancelled_sessions: 0,
      average_rating: undefined,
      total_hours: 0,
      updated_at: new Date()
    };
  }
}

export default new SchedulingServiceNeon();

