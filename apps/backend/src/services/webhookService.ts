/**\n * Webhook System for External Integrations\n * - Event publishing\n * - Payload signing with HMAC\n * - Retry logic with exponential backoff\n * - Webhook delivery tracking\n */\n\nimport axios from 'axios';\nimport crypto from 'crypto';\nimport { log } from '../utils/logger';\n\nexport enum WebhookEventType {\n  USER_REGISTERED = 'user.registered',\n  USER_UPDATED = 'user.updated',\n  USER_DELETED = 'user.deleted',\n  ASSESSMENT_STARTED = 'assessment.started',\n  ASSESSMENT_COMPLETED = 'assessment.completed',\n  ASSESSMENT_UPDATED = 'assessment.updated',\n  RECOMMENDATION_CREATED = 'recommendation.created',\n  MESSAGE_SENT = 'message.sent',\n  ORGANIZATION_CREATED = 'organization.created',\n  ORGANIZATION_UPDATED = 'organization.updated',\n  ORGANIZATION_DELETED = 'organization.deleted',\n  ORGANIZATION_MEMBER_ADDED = 'organization.member.added',\n  ORGANIZATION_MEMBER_REMOVED = 'organization.member.removed',\n}\n\nexport interface WebhookPayload {\n  event: WebhookEventType;\n  timestamp: string;\n  webhookId: string;\n  attemptNumber: number;\n  data: Record<string, any>;\n}\n\nexport interface WebhookSubscription {\n  id: string;\n  organizationId: string;\n  url: string;\n  events: WebhookEventType[];\n  secret: string;\n  active: boolean;\n  createdAt: string;\n  lastTriggeredAt?: string;\n  failureCount: number;\n}\n\nexport interface WebhookDelivery {\n  id: string;\n  webhookId: string;\n  event: WebhookEventType;\n  status: 'pending' | 'delivered' | 'failed';\n  statusCode?: number;\n  attempt: number;\n  nextRetryAt?: string;\n  response?: string;\n  createdAt: string;\n}\n\nclass WebhookService {\n  private readonly maxRetries = 5;\n  private readonly baseDelay = 1000; // 1 second\n  private readonly maxDelay = 3600000; // 1 hour\n  private webhookStore: Map<string, WebhookSubscription> = new Map();\n  private deliveryStore: Map<string, WebhookDelivery> = new Map();\n\n  /**\n   * Subscribe to webhook events\n   */\n  async subscribe(\n    organizationId: string,\n    url: string,\n    events: WebhookEventType[]\n  ): Promise<WebhookSubscription> {\n    const webhookId = `whk_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    const secret = crypto.randomBytes(32).toString('hex');\n\n    const subscription: WebhookSubscription = {\n      id: webhookId,\n      organizationId,\n      url,\n      events,\n      secret,\n      active: true,\n      createdAt: new Date().toISOString(),\n      failureCount: 0,\n    };\n\n    this.webhookStore.set(webhookId, subscription);\n\n    log.info('Webhook subscription created', {\n      webhookId,\n      organizationId,\n      url,\n      events: events.length,\n    });\n\n    return subscription;\n  }\n\n  /**\n   * Unsubscribe from webhooks\n   */\n  async unsubscribe(webhookId: string): Promise<void> {\n    const webhook = this.webhookStore.get(webhookId);\n    if (webhook) {\n      webhook.active = false;\n      log.info('Webhook subscription deactivated', { webhookId });\n    }\n  }\n\n  /**\n   * Get webhook subscriptions for organization\n   */\n  async getSubscriptions(organizationId: string): Promise<WebhookSubscription[]> {\n    return Array.from(this.webhookStore.values()).filter(\n      (w) => w.organizationId === organizationId && w.active\n    );\n  }\n\n  /**\n   * Publish event to subscribed webhooks\n   */\n  async publishEvent(\n    event: WebhookEventType,\n    organizationId: string,\n    data: Record<string, any>\n  ): Promise<void> {\n    try {\n      const subscriptions = await this.getSubscriptions(organizationId);\n      const relevantWebhooks = subscriptions.filter((w) => w.events.includes(event));\n\n      if (relevantWebhooks.length === 0) {\n        log.debug('No webhooks subscribed to event', { event });\n        return;\n      }\n\n      const payload: WebhookPayload = {\n        event,\n        timestamp: new Date().toISOString(),\n        webhookId: '',\n        attemptNumber: 1,\n        data,\n      };\n\n      for (const webhook of relevantWebhooks) {\n        await this.deliverWebhook(webhook, payload);\n      }\n\n      log.info('Event published to webhooks', {\n        event,\n        organizationId,\n        webhookCount: relevantWebhooks.length,\n      });\n    } catch (error) {\n      log.error('Failed to publish webhook event', error as Error, { event, organizationId });\n    }\n  }\n\n  /**\n   * Deliver webhook with retry logic\n   */\n  private async deliverWebhook(\n    webhook: WebhookSubscription,\n    payload: WebhookPayload,\n    attempt: number = 1\n  ): Promise<void> {\n    const deliveryId = `dlv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    const signature = this.generateSignature(payload, webhook.secret);\n\n    const delivery: WebhookDelivery = {\n      id: deliveryId,\n      webhookId: webhook.id,\n      event: payload.event,\n      status: 'pending',\n      attempt,\n      createdAt: new Date().toISOString(),\n    };\n\n    try {\n      const response = await axios.post(webhook.url, payload, {\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Webhook-Signature': signature,\n          'X-Webhook-ID': webhook.id,\n          'X-Delivery-ID': deliveryId,\n          'X-Attempt': attempt.toString(),\n        },\n        timeout: 10000,\n      });\n\n      delivery.status = 'delivered';\n      delivery.statusCode = response.status;\n      webhook.lastTriggeredAt = new Date().toISOString();\n      webhook.failureCount = 0;\n\n      log.info('Webhook delivered successfully', {\n        webhookId: webhook.id,\n        event: payload.event,\n        attempt,\n        statusCode: response.status,\n      });\n    } catch (error) {\n      delivery.status = 'failed';\n      delivery.statusCode = (error as any).response?.status || 0;\n      delivery.response = (error as Error).message;\n      webhook.failureCount++;\n\n      // Schedule retry\n      if (attempt < this.maxRetries && webhook.active) {\n        const delay = this.calculateBackoffDelay(attempt);\n        delivery.nextRetryAt = new Date(Date.now() + delay).toISOString();\n\n        log.warn('Webhook delivery failed, scheduling retry', {\n          webhookId: webhook.id,\n          event: payload.event,\n          attempt,\n          retryIn: `${Math.floor(delay / 1000)}s`,\n        });\n\n        // Schedule retry\n        setTimeout(() => {\n          payload.attemptNumber = attempt + 1;\n          this.deliverWebhook(webhook, payload, attempt + 1);\n        }, delay);\n      } else {\n        log.error('Webhook delivery failed - max retries exceeded', {\n          webhookId: webhook.id,\n          event: payload.event,\n          attempts: attempt,\n        });\n\n        // Disable webhook after too many failures\n        if (webhook.failureCount >= 10) {\n          webhook.active = false;\n          log.security('Webhook disabled due to repeated failures', 'medium', {\n            webhookId: webhook.id,\n          });\n        }\n      }\n    }\n\n    this.deliveryStore.set(deliveryId, delivery);\n  }\n\n  /**\n   * Calculate exponential backoff delay\n   */\n  private calculateBackoffDelay(attempt: number): number {\n    const delay = this.baseDelay * Math.pow(2, attempt - 1);\n    return Math.min(delay, this.maxDelay);\n  }\n\n  /**\n   * Generate HMAC signature for webhook\n   */\n  private generateSignature(payload: WebhookPayload, secret: string): string {\n    const content = JSON.stringify(payload);\n    return crypto\n      .createHmac('sha256', secret)\n      .update(content)\n      .digest('hex');\n  }\n\n  /**\n   * Verify webhook signature\n   */\n  static verifySignature(payload: string, signature: string, secret: string): boolean {\n    const expectedSignature = crypto\n      .createHmac('sha256', secret)\n      .update(payload)\n      .digest('hex');\n\n    return crypto.timingSafeEqual(\n      Buffer.from(signature),\n      Buffer.from(expectedSignature)\n    );\n  }\n\n  /**\n   * Get delivery history\n   */\n  async getDeliveryHistory(\n    webhookId: string,\n    limit: number = 50\n  ): Promise<WebhookDelivery[]> {\n    return Array.from(this.deliveryStore.values())\n      .filter((d) => d.webhookId === webhookId)\n      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())\n      .slice(0, limit);\n  }\n\n  /**\n   * Get webhook statistics\n   */\n  async getWebhookStats(webhookId: string) {\n    const deliveries = await this.getDeliveryHistory(webhookId, 1000);\n    const webhook = this.webhookStore.get(webhookId);\n\n    return {\n      webhookId,\n      active: webhook?.active,\n      failureCount: webhook?.failureCount || 0,\n      deliveries: {\n        total: deliveries.length,\n        succeeded: deliveries.filter((d) => d.status === 'delivered').length,\n        failed: deliveries.filter((d) => d.status === 'failed').length,\n        pending: deliveries.filter((d) => d.status === 'pending').length,\n      },\n      averageResponseTime: this.calculateAverageResponseTime(deliveries),\n      lastDelivery: deliveries[0]?.createdAt,\n    };\n  }\n\n  /**\n   * Calculate average response time\n   */\n  private calculateAverageResponseTime(deliveries: WebhookDelivery[]): number {\n    if (deliveries.length === 0) return 0;\n\n    const successfulDeliveries = deliveries.filter((d) => d.status === 'delivered');\n    if (successfulDeliveries.length === 0) return 0;\n\n    // In real implementation, would track actual response times\n    return 250; // placeholder\n  }\n}\n\nexport const webhookService = new WebhookService();\nexport default webhookService;\n