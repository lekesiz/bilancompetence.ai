/**
 * Health Check Endpoints
 * - /health - Basic health status
 * - /ready - Readiness check (database, external services)
 * - /metrics - Application metrics and statistics
 */

import { Router, Request, Response } from 'express';\nimport { log } from '../utils/logger';\n\nconst router = Router();\n\ninterface HealthStatus {\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  uptime: number;\n  timestamp: string;\n  version: string;\n  environment: string;\n}\n\ninterface ReadinessStatus extends HealthStatus {\n  services: {\n    database: { status: 'ok' | 'error'; latency?: number };\n    redis?: { status: 'ok' | 'error'; latency?: number };\n    auth: { status: 'ok' | 'error' };\n    email?: { status: 'ok' | 'error' };\n    external?: { status: 'ok' | 'error' };\n  };\n}\n\ninterface Metrics {\n  uptime: number;\n  memory: {\n    rss: number;\n    heapTotal: number;\n    heapUsed: number;\n    external: number;\n    arrayBuffers: number;\n  };\n  requests: {\n    total: number;\n    success: number;\n    errors: number;\n    avgResponseTime: number;\n  };\n  database?: {\n    connections: number;\n    queries: number;\n    avgQueryTime: number;\n  };\n}\n\n// Track metrics\nlet metrics = {\n  requestsTotal: 0,\n  requestsSuccess: 0,\n  requestsErrors: 0,\n  totalResponseTime: 0,\n  startTime: Date.now(),\n};\n\n/**\n * GET /health\n * Basic health check - returns 200 if service is up\n */\nrouter.get('/health', (req: Request, res: Response) => {\n  const status: HealthStatus = {\n    status: 'healthy',\n    uptime: Math.floor((Date.now() - metrics.startTime) / 1000),\n    timestamp: new Date().toISOString(),\n    version: process.env.API_VERSION || '1.0.0',\n    environment: process.env.NODE_ENV || 'development',\n  };\n\n  log.debug('Health check', { uptime: status.uptime });\n\n  res.status(200).json(status);\n});\n\n/**\n * GET /ready\n * Readiness check - checks all dependencies are ready\n */\nrouter.get('/ready', async (req: Request, res: Response) => {\n  const startTime = Date.now();\n  const status: ReadinessStatus = {\n    status: 'healthy',\n    uptime: Math.floor((Date.now() - metrics.startTime) / 1000),\n    timestamp: new Date().toISOString(),\n    version: process.env.API_VERSION || '1.0.0',\n    environment: process.env.NODE_ENV || 'development',\n    services: {\n      database: { status: 'ok' },\n      auth: { status: 'ok' },\n    },\n  };\n\n  try {\n    // Check database connectivity\n    const dbStart = Date.now();\n    try {\n      // Simple query to verify connection\n      const supabase = require('@supabase/supabase-js');\n      if (supabase && process.env.SUPABASE_URL) {\n        // Database is configured\n        status.services.database.latency = Date.now() - dbStart;\n      }\n    } catch (error) {\n      status.services.database.status = 'error';\n      status.status = 'degraded';\n    }\n\n    // Check Redis if configured\n    if (process.env.REDIS_URL) {\n      try {\n        const redisStart = Date.now();\n        // Redis would be checked here\n        status.services.redis = {\n          status: 'ok',\n          latency: Date.now() - redisStart,\n        };\n      } catch (error) {\n        status.services.redis = { status: 'error' };\n        status.status = 'degraded';\n      }\n    }\n\n    // Check email service\n    if (process.env.SENDGRID_API_KEY || process.env.SMTP_HOST) {\n      status.services.email = { status: 'ok' };\n    }\n\n    const duration = Date.now() - startTime;\n\n    if (status.status === 'healthy') {\n      log.info('Readiness check passed', { duration });\n      res.status(200).json(status);\n    } else {\n      log.warn('Readiness check degraded', { status });\n      res.status(503).json(status);\n    }\n  } catch (error) {\n    log.error('Readiness check failed', error);\n\n    status.status = 'unhealthy';\n    res.status(503).json(status);\n  }\n});\n\n/**\n * GET /metrics\n * Application metrics and statistics\n */\nrouter.get('/metrics', (req: Request, res: Response) => {\n  const memUsage = process.memoryUsage();\n  const uptime = Math.floor((Date.now() - metrics.startTime) / 1000);\n\n  const metricsData: Metrics = {\n    uptime,\n    memory: {\n      rss: Math.round(memUsage.rss / 1024 / 1024), // MB\n      heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024),\n      heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024),\n      external: Math.round(memUsage.external / 1024 / 1024),\n      arrayBuffers: Math.round(memUsage.arrayBuffers / 1024 / 1024),\n    },\n    requests: {\n      total: metrics.requestsTotal,\n      success: metrics.requestsSuccess,\n      errors: metrics.requestsErrors,\n      avgResponseTime:\n        metrics.requestsTotal > 0\n          ? Math.round(metrics.totalResponseTime / metrics.requestsTotal)\n          : 0,\n    },\n  };\n\n  log.debug('Metrics check', {\n    uptime,\n    memoryHeapUsed: metricsData.memory.heapUsed,\n    requests: metricsData.requests.total,\n  });\n\n  res.status(200).json({\n    status: 'success',\n    data: metricsData,\n  });\n});\n\n/**\n * GET /version\n * API version information\n */\nrouter.get('/version', (req: Request, res: Response) => {\n  res.status(200).json({\n    status: 'success',\n    data: {\n      version: process.env.API_VERSION || '1.0.0',\n      environment: process.env.NODE_ENV || 'development',\n      timestamp: new Date().toISOString(),\n    },\n  });\n});\n\n/**\n * GET /status\n * Comprehensive status report\n */\nrouter.get('/status', async (req: Request, res: Response) => {\n  const report = {\n    status: 'success',\n    timestamp: new Date().toISOString(),\n    environment: process.env.NODE_ENV || 'development',\n    uptime: Math.floor((Date.now() - metrics.startTime) / 1000),\n    services: {\n      api: {\n        status: 'operational',\n        version: process.env.API_VERSION || '1.0.0',\n      },\n      database: {\n        status: process.env.SUPABASE_URL ? 'operational' : 'not-configured',\n      },\n      realtime: {\n        status: process.env.REALTIME_ENABLED === 'true' ? 'operational' : 'disabled',\n      },\n      email: {\n        status: process.env.SENDGRID_API_KEY ? 'operational' : 'not-configured',\n      },\n    },\n    metrics: {\n      memory: {\n        heapUsedMB: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),\n        heapTotalMB: Math.round(process.memoryUsage().heapTotal / 1024 / 1024),\n      },\n      requests: {\n        total: metrics.requestsTotal,\n        avgResponseTimeMs:\n          metrics.requestsTotal > 0\n            ? Math.round(metrics.totalResponseTime / metrics.requestsTotal)\n            : 0,\n      },\n    },\n  };\n\n  log.info('Status report generated');\n\n  res.status(200).json(report);\n});\n\n/**\n * Middleware to track request metrics\n */\nexport function metricsMiddleware(req: any, res: any, next: any) {\n  const startTime = Date.now();\n\n  const originalEnd = res.end;\n  res.end = function (...args: any[]) {\n    const duration = Date.now() - startTime;\n\n    metrics.requestsTotal++;\n    if (res.statusCode < 400) {\n      metrics.requestsSuccess++;\n    } else if (res.statusCode >= 400) {\n      metrics.requestsErrors++;\n    }\n    metrics.totalResponseTime += duration;\n\n    originalEnd.apply(res, args);\n  };\n\n  next();\n}\n\nexport default router;\n